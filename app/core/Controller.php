<?php

namespace app\core;

session_start(); // так как в числе 1 загрузится базовый контроллер то рациональным будет здесь вкл сессию т.к.она будет известна и для видов и для частных контроллеров и для моделей.

// здесь идет общая логика подключения видов и моделей (осуществляются все подключения)
// отсюда будут подключаться все страницы (view) и модели, управляем этими состыковками
// ЕСЛИ В ПАПКЕ CONTROLLERS ЛЕЖИТ 3 ФАЙЛА, ЗНАЧИТ И В ПАПКЕ MODELS ДОЛЖНО БЫТЬ 3 ФАЙЛА по такомуже названию только без слова controller
// все сдесь написанное будет пытаться вызвать на каждой странице 

//abstract - так как не надо на прямую подключать а подлежит только наследованию
abstract class Controller // это БАЗОВЫЙ КЛАСС он нужен для прописывания основной логики на подключение моделей видов и прочего
// в этом абстрактном классе формируется вся логика на подключение последующих видов и моделей (отсюда идет все подключение) 
{
    protected $route;
    protected $view;
    protected $model;
    public function __construct($route) // т.к. подкл виды и модели нам нуженм маршрут ($route) кот прокидывается из рутера (т.е. controller & action) т.к. названия файлов вида и моделей называются по названию контроллера
    {
        $this->route = $route;
        // debug($route);
        $this->view = new View($route); // создаем базовый класс вида (в папке core ) и в него пробрасываем массив $route содержащий controller & action, благодаря которому поним что в папке видов должна быть папка main и в этой папке должен находиться файл index.php

        $model_name = '\app\models\\' . ucfirst($route['controller']); // конфигурируем путь для подключаем модель которая соответствует названию контроллера(например MainController соответствуе модель Main, CatalogueController соответствует Catalogue)
        $this->model = new $model_name; // создали экземпляр нашей модели (например Catalogue у которой емеется медов getCategories)
        //переходим в Main
        // echo "МОДЕЛЬ:";
        // debug($this->model);
        //$this->model->getPages(); // записали в переменную protected mdel и запустили метод getPhones, с добовлением классов коментируем эту строку т.к. к методу getPages должны обращаться не из этого контроллера, а из контроллера кот. ялв. контроллером данной модели 
        // echo __CLASS__;
        //! осуществляем возможность входа на активацию с любой страницы сайта (исп базовый controller т.к он подходит ко всем страницам)
        // debug($this->model);  // можем убедиться что идет понимание на какой странице мы находимся

        // session_destroy();
        // debug($_SESSION);

        // todo ----------------------------------- ниже описан планируемый тернарный оператор (но он не пошел, выдал белый экран) где слева условие после ? (который следует читать как if) действие если пользователь зашел в ветку if когда условие соответсвует true 
        /*
обычная запись
if (a==b) {
    do1
} else {
    do2
}
запись через тернарный оператор где (a==b) - условие, ? вместо if , если в скобках true то do1, : - это else и выполни дейтсвие do2. В тернарном операторе else необходим, елси же его по условию нет необходимости указывать то пишеь null

(a==b) ? do1 : do2;
*/

        // todo ВЫХОД ИЗ ПРОФИЛЯ
        if (isset($_GET['do']) and $_GET['do'] = 'exit') {
            session_unset('do');
            header('location: ' . $_SERVER['REDIRECT_URL']);
            // die();
        }

        //  session_unset (это будет реализация правильного выхода если пользователь захочет выйти при включенной сессии через стрелку назад в браузере) более приемлемо чем session_destroy (это для тестов)


        // todo АТВТОРИЗАЦИЯ проверка данных пришедших из defoult.php пароль и имя
        if (isset($_POST['email']) and isset($_POST['password'])) {
            ////$password_hash = password_hash($_POST['password'], PASSWORD_DEFAULT); // хешируем пароль введенный пользователем для того чтобы в полед сравнить его с паролем в БД.
            $res = $this->model->auth($_POST['email'], $_POST['password']); // этот метод должен запускаться для какойто конкретной модели
            // auth - аутентификация
            // реализуем что пользователь есть и проверяем ввели мы то или не то.
            // debug($_SESSION['auth']);// смотрим что нам пришло с auth

            if ($res) {
                // $_SESSION['auth'] = true; // 1 ВАРИАНТ задания сесси. Это если необходима регистрация пользователя но этот пользователь не будет что то покупать или класть в карзину и для него не будет работать БД под его действия. Для этого метода не понятно для какаго пользователья необходимо совершить дейтсвия в БД и сохранить например товар купленный им.
                $_SESSION['auth'] = ['id' => $res['id'], 'email' => $res['email']]; // 2 ВАРИАТ для того чтобы пользователь мог совершать действия на сайте с их отражением в БД. это чтобы БД понимала для какого пользователя совершаются дейтсвия и чьи дейтсвия необходимо запомнить. пароль не берем в целях безопасности
                header('location: ' . $_SERVER['REDIRECT_URL']); // производим редирект на этойже странице
                // die(); // здесь die писать не следует а так его пишем для того чтобы не читать нижеидущий код. РЕКОМЕНДУЕТСЯ это писать после каждого header or redirect
            } else {
                /*
                echo "<script> 
                document.addEventListener('DOMContentLoaded', function () {
                    var elems = document.querySelectorAll('.modal');
                    var instances = M.Modal.init(elems, 'open');
                    var instance = M.Modal.getInstance(document.querySelector('#modal-auth'));
                    instance.open();
                }); 
                </script>"; // через echo php выводим JS script - это возможно.
                */
                //header('refresh:2; location: ' . $_SERVER['REDIRECT_URL']); // делаем редерект и убираем сообщение об вводе не верных данных.
                echo "
                <div class='card-panel red lighten-2 auth-error' style='position: absolute; left: 50%; top: 30%; transform: translate(-50%, -50%)'>Вы ввели не верные данные</div>";

                // <script>setTimeout(function(){
                // document.querySelector('.auth-error').remove();
                // },1500)</script>


                // выше описан вывод соббщения об вводе неверных дынных при помощи <div> из materialize. В скрипте указана функция на удоление класса по истечении заданного промежутка времени 1,5сек.
            }
        }
        // debug($_POST); // видим что приходит от пользователя заполнившего и отправившего форму
        // debug($_GET['do']); // проверяем доступность _GET параметра из defaul.php который указывали для кнопки выйти. Он доступен т.к. Controller.php is parent class!!!
    }


    // todo вызываем isAjax() в catalogueController
    public function isAjax()
    {
        // echo "ajax";
        //метод проверяет был ли аякс запрос или нет. Если да - то возвр Истина, иначе - Ложь
        // var_dump(isset($_SERVER['HTTP_X_REQUESTED_WITH']) && $_SERVER['HTTP_X_REQUESTED_WITH'] === 'XMLHttpRequest');
        return isset($_SERVER['HTTP_X_REQUESTED_WITH']) && $_SERVER['HTTP_X_REQUESTED_WITH'] === 'XMLHttpRequest';
    }
}
